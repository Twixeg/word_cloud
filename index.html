<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>–û–±–ª–∞–∫–æ —Å–ª–æ–≤</title>

    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@600;700&display=swap" rel="stylesheet" />

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-cloud@1.2.5/build/d3.layout.cloud.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–Ω–∏–º–∏—Ä—É–µ–º—ã–π —Ñ–æ–Ω */
        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 300% 300%;
            animation: gradientShift 15s ease infinite alternate, gradientFlow 25s ease-in-out infinite;
            will-change: background-position, background-size;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes gradientFlow {
            0% { background-size: 300% 300%; }
            50% { background-size: 200% 200%; }
            100% { background-size: 300% 300%; }
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Open Sans', Arial, sans-serif;
            color: white;
            background: transparent;
            display: flex;
            flex-direction: column;
            touch-action: manipulation;
        }

        #container {
            width: 100%;
            padding: 20px;
            text-align: center;
            z-index: 10;
            position: relative;
            pointer-events: auto;
        }

        h1 {
            font-size: clamp(2rem, 4vw, 3.5rem);
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.4);
            letter-spacing: -0.5px;
            transform: translateZ(0);
        }

        p.lead {
            font-size: clamp(1rem, 2.5vw, 1.4rem);
            max-width: 80%;
            margin: 0 auto 20px;
            opacity: 0.9;
            text-shadow: 0 1px 4px rgba(0,0,0,0.5);
            transform: translateZ(0);
        }

        .form-link {
            display: inline-block;
            padding: 12px 28px;
            background: #ff6b35;
            color: white;
            text-decoration: none;
            border-radius: 50px;
            font-weight: 600;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.3s;
            will-change: transform;
            backface-visibility: hidden;
        }

        .form-link:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        button#refresh {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.2s;
            will-change: transform;
            backface-visibility: hidden;
        }

        button#refresh:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }

        button#refresh:active {
            transform: translateY(0);
        }

        .loading {
            font-style: italic;
            margin-top: 10px;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            color: #e0f7fa;
            text-shadow: 0 1px 3px rgba(0,0,0,0.4);
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            contain: layout style paint;
        }
        
        #wordcloud-canvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            will-change: transform;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            
            p.lead {
                font-size: 1.1rem;
                max-width: 90%;
            }
            
            .form-link {
                padding: 10px 20px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="background"></div>

    <div id="container">
        <h1>–ß—Ç–æ –¥–ª—è –í–∞—Å –∑–Ω–∞—á–∏—Ç —Å–ª–æ–≤–æ "–ü–∞—Ç—Ä–∏–æ—Ç–∏–∑–º"?</h1>
        <p class="lead">–ü—Ä–æ–π–¥–∏—Ç–µ —Ñ–æ—Ä–º—É ‚Äî –≤–∞—à–µ —Å–ª–æ–≤–æ —Å—Ç–∞–Ω–µ—Ç —á–∞—Å—Ç—å—é –æ–±—â–µ–≥–æ –æ–±–ª–∞–∫–∞!</p>
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSc6SUsLHNuJ6gSkoaaojPnDuYbZMnftZwYp_livh25zJcAn8A/viewform?usp=header" target="_blank" class="form-link">–ü—Ä–æ–π—Ç–∏ —Ñ–æ—Ä–º—É</a>
        <button id="refresh">üîÑ –û–±–Ω–æ–≤–∏—Ç—å</button>
        <p class="loading" id="status">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</p>
    </div>

    <div id="canvas-wrapper">
        <canvas id="wordcloud-canvas"></canvas>
    </div>

    <script>
        const GAS_JSONP_URL = "https://script.google.com/macros/s/AKfycbyLQ2achxsI5EL8HXtFJGUlB0yeQeaSCGcgu6OD74eMFVGYUpuUard90yRey6I15BYX/exec";
        const statusText = document.getElementById("status");
        const canvas = document.getElementById("wordcloud-canvas");
        const ctx = canvas.getContext("2d", { alpha: true });
        const canvasWrapper = document.getElementById("canvas-wrapper");
        
        let currentWords = null;
        let width, height;
        let resizeTimeout = null;

        const wordColors = [
            '#ff6b6b', '#ff9f43', '#feca57', '#ffeaa7', '#55efc4',
            '#81ecec', '#74b9ff', '#a29bfe', '#dfe6e9', '#00cec9'
        ].map(color => ({
            fill: color,
            stroke: 'rgba(255, 255, 255, 0.9)'
        }));
        
        const floatRange = 8;
        const animationDuration = 1200;
        const shadowBlur = 6;
        const MAX_WORDS = 80;

        function resizeCanvas() {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            
            resizeTimeout = setTimeout(() => {
                const newWidth = canvasWrapper.offsetWidth;
                const newHeight = canvasWrapper.offsetHeight;
                
                if (newWidth === 0 || newHeight === 0) return;
                
                width = newWidth;
                height = newHeight;
                
                const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                ctx.scale(dpr, dpr);
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ—Ç —Å–ª–æ–≤
                if (!currentWords) {
                    statusText.style.opacity = 1;
                }
                
                if (currentWords) {
                    generateWordCloud(currentWords);
                }
            }, 50);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        function initializeCanvas() {
            resizeCanvas();
            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –≤—ã–∑–æ–≤ —Ä–µ—Å–∞–π–∑–∞ –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            setTimeout(resizeCanvas, 100);
        }

        if ('ResizeObserver' in window) {
            const resizeObserver = new ResizeObserver(initializeCanvas);
            resizeObserver.observe(canvasWrapper);
        } else {
            window.addEventListener("resize", initializeCanvas);
        }

        const refreshBtn = document.getElementById("refresh");
        refreshBtn.addEventListener("click", loadFromGoogleSheets, { passive: true });

        function loadFromGoogleSheets() {
            statusText.style.opacity = 1;
            statusText.textContent = "–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...";
            
            const oldScript = document.getElementById("jsonp-script");
            if (oldScript) oldScript.remove();

            const script = document.createElement("script");
            script.id = "jsonp-script";
            script.src = `${GAS_JSONP_URL}?callback=handleData&t=${Date.now()}`;
            script.async = true;
            script.onload = () => script.remove();
            script.onerror = () => {
                statusText.textContent = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö.";
                script.remove();
            };
            
            document.head.appendChild(script);
        }

        function handleData(data) {
            const now = Date.now();
            
            if (!data || data.length === 0) {
                statusText.textContent = "–ü–æ–∫–∞ –Ω–µ—Ç –æ—Ç–≤–µ—Ç–æ–≤. –ë—É–¥—å—Ç–µ –ø–µ—Ä–≤—ã–º!";
                return;
            }

            if (data.error) {
                console.error("–û—à–∏–±–∫–∞:", data.message);
                statusText.textContent = "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.";
                return;
            }

            try {
                const keys = Object.keys(data[0] || {});
                const textColumn = keys.length > 1 ? keys[keys.length - 1] : keys[0];
                const allText = data.map(row => (row[textColumn] || "").trim()).join(" ");

                const words = extractWords(allText);
                if (words.length === 0) {
                    statusText.textContent = "–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–ª–æ–≤.";
                    return;
                }

                currentWords = words;
                
                // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Ä–µ—Å–∞–π–∑ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                resizeCanvas();
                
                // –°–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
                setTimeout(() => {
                    statusText.style.opacity = 0;
                }, 1500);
                
                statusText.textContent = `–ü–æ–∫–∞–∑–∞–Ω–æ ${Math.min(words.length, MAX_WORDS)} —Å–ª–æ–≤.`;
            } catch (err) {
                console.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏:", err);
                statusText.textContent = "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–∫—Å—Ç–∞.";
            }
        }

        const stopWordsSet = new Set([
            '–∏', '–≤', '–Ω–∞', '—Å', '–∫', '—É', '–ø–æ', '–Ω–æ', '–∞', '—è', '–º—ã', '–≤—ã', '–æ–Ω', '–æ–Ω–∞', '–æ–Ω–∏',
            '—ç—Ç–æ', '—Ç–æ—Ç', '—Ç–∞–∫', '–∫–∞–∫', '–∂–µ', '–ª–∏', '–±—ã', '—á—Ç–æ', '–∫–æ—Ç–æ—Ä—ã–π', '–µ—Å–ª–∏', '–∏–ª–∏',
            '–≤—Å–µ', '–≤–µ—Å—å', '—ç—Ç–æ—Ç', '–¥–ª—è', '–±—ã—Ç—å', '–µ–≥–æ', '–µ–µ', '–∏—Ö', '–º–Ω–µ', '–º–µ–Ω—è', '—Ç–µ–±—è',
            '—á–µ–º', '–∫—Ç–æ', '–≥–¥–µ', '–∫–æ–≥–¥–∞', '–ø–æ—á–µ–º—É', '–∑–∞—á–µ–º', '–ø–æ—Ç–æ–º—É', '—Å–≤–æ–∏', '—Å–≤–æ–π', '—Å–≤–æ—é'
        ]);

        function extractWords(text) {
            const cleanText = text
                .toLowerCase()
                .replace(/[^\w\s–∞-—è—ë-]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();

            if (!cleanText) return [];

            const freq = {};
            const words = cleanText.split(' ');
            
            for (let word of words) {
                if (word.length > 2 && !stopWordsSet.has(word)) {
                    freq[word] = (freq[word] || 0) + 1;
                }
            }

            if (Object.keys(freq).length === 0) return [];

            const entries = Object.entries(freq);
            entries.sort((a, b) => b[1] - a[1]);

            const maxFreq = entries[0][1];
            const top3Words = new Set(entries.slice(0, 3).map(([text]) => text));
            
            const minSize = 20;
            const maxSize = 80;
            const sizeDiff = maxSize - minSize;

            return entries.slice(0, MAX_WORDS).map(([text, count]) => ({
                text: text.charAt(0).toUpperCase() + text.slice(1),
                size: top3Words.has(text) ? 
                    minSize + sizeDiff * (count / maxFreq) * 1.3 : 
                    minSize + sizeDiff * (count / maxFreq),
                frequency: count,
                colorIndex: Math.floor(Math.random() * wordColors.length)
            }));
        }

        const animatedWords = [];
        let animationFrameId = null;

        function generateWordCloud(words) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            animatedWords.length = 0;

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ –ø–µ—Ä–µ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π
            if (!width || !height) {
                setTimeout(() => generateWordCloud(words), 100);
                return;
            }

            d3.layout.cloud()
                .size([width, height])
                .words(words)
                .padding(3) // –£–≤–µ–ª–∏—á–∏–ª padding –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
                .rotate(() => 0)
                .font("'Open Sans', sans-serif")
                .fontSize(d => d.size)
                .spiral('rectangular')
                .on("end", (newWords) => {
                    const now = performance.now();
                    
                    newWords.forEach(word => {
                        word.initialX = word.x;
                        word.initialY = word.y;
                        word.animationOffset = Math.random() * Math.PI * 2;
                        word.colorIndex = Math.floor(Math.random() * wordColors.length);
                    });
                    
                    animatedWords.push(...newWords);
                    startAnimation(true);
                })
                .start();
        }

        function startAnimation(isInitial = false) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            const startTime = isInitial ? performance.now() : 0;
            
            function animate(now) {
                if (!width || !height) {
                    animationFrameId = requestAnimationFrame(animate);
                    return;
                }
                
                ctx.clearRect(0, 0, width, height);
                ctx.save();
                ctx.translate(width / 2, height / 2);

                const elapsedTime = now - startTime;
                const progress = isInitial ? Math.min(elapsedTime / animationDuration, 1) : 1;
                
                const easeProgress = d3.easeCubicInOut(progress);

                const timeFactor = now / 2000;
                
                animatedWords.forEach((word) => {
                    const t = timeFactor + word.animationOffset;
                    const xOffset = Math.sin(t) * floatRange * easeProgress;
                    const yOffset = Math.cos(t) * floatRange * easeProgress;

                    const currentSize = word.size * easeProgress;
                    
                    const color = wordColors[word.colorIndex];
                    ctx.fillStyle = color.fill;
                    ctx.strokeStyle = color.stroke;
                    ctx.lineWidth = 1;
                    ctx.font = `${currentSize}px 'Open Sans', sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    
                    ctx.shadowBlur = shadowBlur * easeProgress;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    
                    ctx.save();
                    ctx.translate(word.initialX + xOffset, word.initialY + yOffset);
                    
                    ctx.strokeText(word.text.toUpperCase(), 0, 0);
                    ctx.fillText(word.text.toUpperCase(), 0, 0);
                    
                    ctx.restore();
                });
                
                ctx.restore();
                
                animationFrameId = requestAnimationFrame(animate);
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }

        function init() {
            initializeCanvas();
            loadFromGoogleSheets();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
