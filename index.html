<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>–û–±–ª–∞–∫–æ —Å–ª–æ–≤</title>

    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&display=swap" rel="stylesheet" />

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-cloud@1.2.5/build/d3.layout.cloud.min.js"></script>

    <style>
        :root {
            --primary-color: #ff6b35;
            --secondary-color: #4CAF50;
            --text-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–æ–Ω */
        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 300% 300%;
            animation: gradientShift 15s ease infinite alternate;
            will-change: background-position;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            color: var(--text-color);
            background: transparent;
            display: flex;
            flex-direction: column;
        }

        #container {
            width: 100%;
            padding: 20px;
            text-align: center;
            z-index: 10;
            position: relative;
        }

        h1 {
            font-size: clamp(1.8rem, 5vw, 3rem);
            font-weight: 700;
            margin-bottom: 12px;
            text-shadow: 0 4px 8px var(--shadow-color);
        }

        p.lead {
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            max-width: 90%;
            margin: 0 auto 20px;
            opacity: 0.9;
            text-shadow: 0 2px 4px var(--shadow-color);
        }

        .form-link {
            display: inline-block;
            padding: 12px 28px;
            background: var(--primary-color);
            color: var(--text-color);
            text-decoration: none;
            border-radius: 50px;
            font-weight: 700;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.3s;
        }

        .form-link:hover,
        .form-link:active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        button#refresh {
            margin-top: 15px;
            padding: 10px 24px;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }

        button#refresh:hover,
        button#refresh:active {
            background-color: #3e8e41;
            transform: translateY(-1px);
        }

        .loading {
            font-style: italic;
            margin-top: 10px;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            color: #c5e1a5;
            text-shadow: 0 1px 3px var(--shadow-color);
            opacity: 1;
        }
        
        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            contain: layout style paint;
        }
        
        #wordcloud-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="background"></div>

    <div id="container">
        <h1>–ß—Ç–æ –¥–ª—è –í–∞—Å –∑–Ω–∞—á–∏—Ç —Å–ª–æ–≤–æ "–ü–∞—Ç—Ä–∏–æ—Ç–∏–∑–º"?</h1>
        <p class="lead">–ü—Ä–æ–π–¥–∏—Ç–µ —Ñ–æ—Ä–º—É ‚Äî –≤–∞—à–µ —Å–ª–æ–≤–æ —Å—Ç–∞–Ω–µ—Ç —á–∞—Å—Ç—å—é –æ–±—â–µ–≥–æ –æ–±–ª–∞–∫–∞!</p>
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSc6SUsLHNuJ6gSkoaaojPnDuYbZMnftZwYp_livh25zJcAn8A/viewform?usp=header" target="_blank" class="form-link">–ü—Ä–æ–π—Ç–∏ —Ñ–æ—Ä–º—É</a>
        <button id="refresh">üîÑ –û–±–Ω–æ–≤–∏—Ç—å</button>
        <p class="loading" id="status">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</p>
    </div>

    <div id="canvas-wrapper">
        <canvas id="wordcloud-canvas"></canvas>
    </div>

    <script>
        const GAS_JSONP_URL = "https://script.google.com/macros/s/AKfycbyLQ2achxsI5EL8HXtFJGUlB0yeQeaSCGcgu6OD74eMFVGYUpuUard90yRey6I15BYX/exec";
        const statusText = document.getElementById("status");
        const canvas = document.getElementById("wordcloud-canvas");
        const ctx = canvas.getContext("2d");
        const canvasWrapper = document.getElementById("canvas-wrapper");
        
        let currentWords = null;
        let width, height;

        const wordColors = [
            '#ff6b6b', '#ff9f43', '#feca57', '#ffeaa7', '#55efc4',
            '#81ecec', '#74b9ff', '#a29bfe', '#dfe6e9', '#00cec9'
        ].map(color => ({
            fill: color,
            stroke: 'rgba(255, 255, 255, 0.7)' // –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π –±–µ–ª—ã–π –∫–æ–Ω—Ç—É—Ä
        }));

        const floatRange = 5;
        const animationDuration = 1000;
        const MAX_WORDS = 60; 

        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ ResizeObserver –¥–ª—è –Ω–∞–¥—ë–∂–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const newWidth = entry.contentRect.width;
                const newHeight = entry.contentRect.height;
                
                if (width !== newWidth || height !== newHeight) {
                    width = newWidth;
                    height = newHeight;
                    const dpr = window.devicePixelRatio || 1;
                    
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    ctx.scale(dpr, dpr);

                    if (currentWords) {
                        generateWordCloud(currentWords);
                    }
                }
            }
        });

        // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤ –æ–±–µ—Ä—Ç–∫–∏
        resizeObserver.observe(canvasWrapper);
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        function loadFromGoogleSheets() {
            statusText.style.opacity = 1;
            statusText.textContent = "–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...";
            
            const oldScript = document.getElementById("jsonp-script");
            if (oldScript) oldScript.remove();

            const script = document.createElement("script");
            script.id = "jsonp-script";
            script.src = `${GAS_JSONP_URL}?callback=handleData&t=${Date.now()}`;
            script.async = true;
            script.onload = () => script.remove();
            script.onerror = () => {
                statusText.textContent = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö.";
                script.remove();
            };
            
            document.head.appendChild(script);
        }

        function handleData(data) {
            if (!data || data.length === 0) {
                statusText.textContent = "–ü–æ–∫–∞ –Ω–µ—Ç –æ—Ç–≤–µ—Ç–æ–≤. –ë—É–¥—å—Ç–µ –ø–µ—Ä–≤—ã–º!";
                return;
            }

            if (data.error) {
                console.error("–û—à–∏–±–∫–∞:", data.message);
                statusText.textContent = "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.";
                return;
            }

            try {
                const keys = Object.keys(data[0] || {});
                const textColumn = keys.length > 1 ? keys[keys.length - 1] : keys[0];
                const allText = data.map(row => (row[textColumn] || "").trim()).join(" ");

                const words = extractWords(allText);
                if (words.length === 0) {
                    statusText.textContent = "–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–ª–æ–≤.";
                    return;
                }

                currentWords = words;
                generateWordCloud(words);
                
                setTimeout(() => {
                    statusText.style.opacity = 0;
                }, 1000);
                
                statusText.textContent = `–ü–æ–∫–∞–∑–∞–Ω–æ ${words.length} —Å–ª–æ–≤.`;
            } catch (err) {
                console.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏:", err);
                statusText.textContent = "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–∫—Å—Ç–∞.";
            }
        }

        // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ª–æ–≤
        const stopWordsSet = new Set([
            '—Ö—É–π', '–ø–∏–∑–¥–∞', '—Ö–µ—Ä', '–ª–æ—Ö', '–ø–∏–¥–æ—Ä'
        ]);

        function extractWords(text) {
            const cleanText = text
                .toLowerCase()
                .replace(/[^\w\s–∞-—è—ë-]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();

            if (!cleanText) return [];

            const freq = {};
            const words = cleanText.split(' ');
            
            for (let word of words) {
                if (word.length > 2 && !stopWordsSet.has(word)) {
                    freq[word] = (freq[word] || 0) + 1;
                }
            }

            if (Object.keys(freq).length === 0) return [];

            const entries = Object.entries(freq);
            entries.sort((a, b) => b[1] - a[1]);

            const maxFreq = entries[0][1];
            
            const minSize = 16;
            const maxSize = 60;
            const sizeDiff = maxSize - minSize;

            return entries.slice(0, MAX_WORDS).map(([text, count]) => ({
                text: text.charAt(0).toUpperCase() + text.slice(1),
                size: minSize + sizeDiff * (count / maxFreq),
                frequency: count,
                colorIndex: Math.floor(Math.random() * wordColors.length)
            }));
        }

        const animatedWords = [];
        let animationFrameId = null;

        function generateWordCloud(words) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            animatedWords.length = 0;
            ctx.clearRect(0, 0, width, height);

            if (width < 10 || height < 10) {
                return;
            }

            d3.layout.cloud()
                .size([width, height])
                .words(words)
                .padding(4)
                .rotate(() => 0)
                .font("'Montserrat', sans-serif")
                .fontSize(d => d.size)
                .spiral('rectangular')
                .on("end", draw)
                .start();

            function draw(newWords) {
                newWords.forEach(word => {
                    word.initialX = word.x;
                    word.initialY = word.y;
                    word.animationOffset = Math.random() * Math.PI * 2;
                });
                
                animatedWords.push(...newWords);
                startAnimation();
            }
        }

        function startAnimation() {
            const startTime = performance.now();
            
            function animate(now) {
                if (!width || !height) {
                    animationFrameId = requestAnimationFrame(animate);
                    return;
                }
                
                ctx.clearRect(0, 0, width, height);
                ctx.save();
                ctx.translate(width / 2, height / 2);

                const elapsedTime = now - startTime;
                const progress = Math.min(elapsedTime / animationDuration, 1);
                
                const easeProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const timeFactor = now / 2000;
                
                animatedWords.forEach((word) => {
                    const t = timeFactor + word.animationOffset;
                    const xOffset = Math.sin(t) * floatRange * easeProgress;
                    const yOffset = Math.cos(t) * floatRange * easeProgress;

                    const currentSize = word.size * easeProgress;
                    
                    const color = wordColors[word.colorIndex];
                    ctx.fillStyle = color.fill;
                    ctx.strokeStyle = color.stroke;
                    ctx.lineWidth = 1;

                    ctx.font = `${currentSize}px 'Montserrat', sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    
                    ctx.shadowBlur = 4 * easeProgress;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                    
                    ctx.save();
                    ctx.translate(word.initialX + xOffset, word.initialY + yOffset);
                    
                    ctx.strokeText(word.text, 0, 0);
                    ctx.fillText(word.text, 0, 0);
                    
                    ctx.restore();
                });
                
                ctx.restore();
                
                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    animationFrameId = requestAnimationFrame(floatAnimation);
                }
            }
            
            function floatAnimation(now) {
                if (!width || !height) {
                    animationFrameId = requestAnimationFrame(floatAnimation);
                    return;
                }
                
                ctx.clearRect(0, 0, width, height);
                ctx.save();
                ctx.translate(width / 2, height / 2);

                const timeFactor = now / 2000;
                
                animatedWords.forEach((word) => {
                    const t = timeFactor + word.animationOffset;
                    const xOffset = Math.sin(t) * floatRange;
                    const yOffset = Math.cos(t) * floatRange;

                    const color = wordColors[word.colorIndex];
                    ctx.fillStyle = color.fill;
                    ctx.strokeStyle = color.stroke;
                    ctx.lineWidth = 1;
                    
                    ctx.font = `${word.size}px 'Montserrat', sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                    
                    ctx.save();
                    ctx.translate(word.initialX + xOffset, word.initialY + yOffset);
                    
                    ctx.strokeText(word.text, 0, 0);
                    ctx.fillText(word.text, 0, 0);
                    
                    ctx.restore();
                });
                
                ctx.restore();
                animationFrameId = requestAnimationFrame(floatAnimation);
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', () => {
            loadFromGoogleSheets();
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏
        document.getElementById("refresh").addEventListener("click", loadFromGoogleSheets);

        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
